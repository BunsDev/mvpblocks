{
  "name": "github-globe",
  "type": "registry:block",
  "dependencies": [
    "react",
    "@react-three/drei",
    "@react-three/fiber",
    "three",
    "three-globe"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:block",
      "content": "\"use client\";\r\nimport { useEffect, useRef, useState } from \"react\";\r\nimport * as THREE from \"three\";\r\nimport { Color, Scene, Fog, PerspectiveCamera, Vector3, Group } from \"three\";\r\nimport ThreeGlobe from \"three-globe\";\r\nimport { useThree, Canvas, extend } from \"@react-three/fiber\";\r\nimport { OrbitControls } from \"@react-three/drei\";\r\nimport countries from \"@/data/globe.json\";\r\n\r\ndeclare module \"@react-three/fiber\" {\r\n  interface ThreeElements {\r\n    threeGlobe: ThreeElements[\"mesh\"] & {\r\n      new (): ThreeGlobe;\r\n    };\r\n  }\r\n}\r\n\r\nextend({ ThreeGlobe: ThreeGlobe });\r\n\r\nconst RING_PROPAGATION_SPEED = 3;\r\nconst aspect = 1.2;\r\nconst cameraZ = 300;\r\n\r\ntype Position = {\r\n  order: number;\r\n  startLat: number;\r\n  startLng: number;\r\n  endLat: number;\r\n  endLng: number;\r\n  arcAlt: number;\r\n  color: string;\r\n};\r\n\r\nexport type GlobeConfig = {\r\n  pointSize?: number;\r\n  globeColor?: string;\r\n  showAtmosphere?: boolean;\r\n  atmosphereColor?: string;\r\n  atmosphereAltitude?: number;\r\n  emissive?: string;\r\n  emissiveIntensity?: number;\r\n  shininess?: number;\r\n  polygonColor?: string;\r\n  ambientLight?: string;\r\n  directionalLeftLight?: string;\r\n  directionalTopLight?: string;\r\n  pointLight?: string;\r\n  arcTime?: number;\r\n  arcLength?: number;\r\n  rings?: number;\r\n  maxRings?: number;\r\n  initialPosition?: {\r\n    lat: number;\r\n    lng: number;\r\n  };\r\n  autoRotate?: boolean;\r\n  autoRotateSpeed?: number;\r\n};\r\n\r\ninterface WorldProps {\r\n  globeConfig: GlobeConfig;\r\n  data: Position[];\r\n}\r\n\r\nlet numbersOfRings = [0];\r\n\r\nexport function Globe({ globeConfig, data }: WorldProps) {\r\n  const globeRef = useRef<ThreeGlobe | null>(null);\r\n  const groupRef = useRef<THREE.Group | null>(null);\r\n  const [isInitialized, setIsInitialized] = useState(false);\r\n\r\n  const defaultProps = {\r\n    pointSize: 1,\r\n    atmosphereColor: \"#ffffff\",\r\n    showAtmosphere: true,\r\n    atmosphereAltitude: 0.1,\r\n    polygonColor: \"rgba(255,255,255,0.7)\",\r\n    globeColor: \"#1d072e\",\r\n    emissive: \"#000000\",\r\n    emissiveIntensity: 0.1,\r\n    shininess: 0.9,\r\n    arcTime: 2000,\r\n    arcLength: 0.9,\r\n    rings: 1,\r\n    maxRings: 3,\r\n    ...globeConfig,\r\n  };\r\n\r\n  // Initialize globe only once\r\n  useEffect(() => {\r\n    if (!globeRef.current && groupRef.current) {\r\n      globeRef.current = new ThreeGlobe();\r\n      (groupRef.current as any).add(globeRef.current);\r\n      setIsInitialized(true);\r\n    }\r\n  }, []);\r\n\r\n  // Build material when globe is initialized or when relevant props change\r\n  useEffect(() => {\r\n    if (!globeRef.current || !isInitialized) return;\r\n\r\n    const globeMaterial = globeRef.current.globeMaterial() as unknown as {\r\n      color: Color;\r\n      emissive: Color;\r\n      emissiveIntensity: number;\r\n      shininess: number;\r\n    };\r\n    globeMaterial.color = new Color(globeConfig.globeColor);\r\n    globeMaterial.emissive = new Color(globeConfig.emissive);\r\n    globeMaterial.emissiveIntensity = globeConfig.emissiveIntensity || 0.1;\r\n    globeMaterial.shininess = globeConfig.shininess || 0.9;\r\n  }, [\r\n    isInitialized,\r\n    globeConfig.globeColor,\r\n    globeConfig.emissive,\r\n    globeConfig.emissiveIntensity,\r\n    globeConfig.shininess,\r\n  ]);\r\n\r\n  // Build data when globe is initialized or when data changes\r\n  useEffect(() => {\r\n    if (!globeRef.current || !isInitialized || !data) return;\r\n\r\n    const arcs = data;\r\n    let points = [];\r\n    for (let i = 0; i < arcs.length; i++) {\r\n      const arc = arcs[i];\r\n      const rgb = hexToRgb(arc.color) as { r: number; g: number; b: number };\r\n      points.push({\r\n        size: defaultProps.pointSize,\r\n        order: arc.order,\r\n        color: arc.color,\r\n        lat: arc.startLat,\r\n        lng: arc.startLng,\r\n      });\r\n      points.push({\r\n        size: defaultProps.pointSize,\r\n        order: arc.order,\r\n        color: arc.color,\r\n        lat: arc.endLat,\r\n        lng: arc.endLng,\r\n      });\r\n    }\r\n\r\n    // remove duplicates for same lat and lng\r\n    const filteredPoints = points.filter(\r\n      (v, i, a) =>\r\n        a.findIndex((v2) =>\r\n          [\"lat\", \"lng\"].every(\r\n            (k) => v2[k as \"lat\" | \"lng\"] === v[k as \"lat\" | \"lng\"],\r\n          ),\r\n        ) === i,\r\n    );\r\n\r\n    globeRef.current\r\n      .hexPolygonsData(countries.features)\r\n      .hexPolygonResolution(3)\r\n      .hexPolygonMargin(0.7)\r\n      .showAtmosphere(defaultProps.showAtmosphere)\r\n      .atmosphereColor(defaultProps.atmosphereColor)\r\n      .atmosphereAltitude(defaultProps.atmosphereAltitude)\r\n      .hexPolygonColor(() => defaultProps.polygonColor);\r\n\r\n    globeRef.current\r\n      .arcsData(data)\r\n      .arcStartLat((d) => (d as { startLat: number }).startLat * 1)\r\n      .arcStartLng((d) => (d as { startLng: number }).startLng * 1)\r\n      .arcEndLat((d) => (d as { endLat: number }).endLat * 1)\r\n      .arcEndLng((d) => (d as { endLng: number }).endLng * 1)\r\n      .arcColor((e: any) => (e as { color: string }).color)\r\n      .arcAltitude((e) => (e as { arcAlt: number }).arcAlt * 1)\r\n      .arcStroke(() => [0.32, 0.28, 0.3][Math.round(Math.random() * 2)])\r\n      .arcDashLength(defaultProps.arcLength)\r\n      .arcDashInitialGap((e) => (e as { order: number }).order * 1)\r\n      .arcDashGap(15)\r\n      .arcDashAnimateTime(() => defaultProps.arcTime);\r\n\r\n    globeRef.current\r\n      .pointsData(filteredPoints)\r\n      .pointColor((e) => (e as { color: string }).color)\r\n      .pointsMerge(true)\r\n      .pointAltitude(0.0)\r\n      .pointRadius(2);\r\n\r\n    globeRef.current\r\n      .ringsData([])\r\n      .ringColor(() => defaultProps.polygonColor)\r\n      .ringMaxRadius(defaultProps.maxRings)\r\n      .ringPropagationSpeed(RING_PROPAGATION_SPEED)\r\n      .ringRepeatPeriod(\r\n        (defaultProps.arcTime * defaultProps.arcLength) / defaultProps.rings,\r\n      );\r\n  }, [\r\n    isInitialized,\r\n    data,\r\n    defaultProps.pointSize,\r\n    defaultProps.showAtmosphere,\r\n    defaultProps.atmosphereColor,\r\n    defaultProps.atmosphereAltitude,\r\n    defaultProps.polygonColor,\r\n    defaultProps.arcLength,\r\n    defaultProps.arcTime,\r\n    defaultProps.rings,\r\n    defaultProps.maxRings,\r\n  ]);\r\n\r\n  // Handle rings animation with cleanup\r\n  useEffect(() => {\r\n    if (!globeRef.current || !isInitialized || !data) return;\r\n\r\n    const interval = setInterval(() => {\r\n      if (!globeRef.current) return;\r\n\r\n      const newNumbersOfRings = genRandomNumbers(\r\n        0,\r\n        data.length,\r\n        Math.floor((data.length * 4) / 5),\r\n      );\r\n\r\n      const ringsData = data\r\n        .filter((d, i) => newNumbersOfRings.includes(i))\r\n        .map((d) => ({\r\n          lat: d.startLat,\r\n          lng: d.startLng,\r\n          color: d.color,\r\n        }));\r\n\r\n      globeRef.current.ringsData(ringsData);\r\n    }, 2000);\r\n\r\n    return () => {\r\n      clearInterval(interval);\r\n    };\r\n  }, [isInitialized, data]);\r\n\r\n  return <group ref={groupRef} />;\r\n}\r\n\r\nexport function WebGLRendererConfig() {\r\n  const { gl, size } = useThree();\r\n\r\n  useEffect(() => {\r\n    gl.setPixelRatio(window.devicePixelRatio);\r\n    gl.setSize(size.width, size.height);\r\n    gl.setClearColor(0xffaaff, 0);\r\n  }, []);\r\n\r\n  return null;\r\n}\r\n\r\nexport function World(props: WorldProps) {\r\n  const { globeConfig } = props;\r\n  const scene = new Scene();\r\n  scene.fog = new Fog(0xffffff, 400, 2000);\r\n  return (\r\n    <Canvas scene={scene} camera={new PerspectiveCamera(50, aspect, 180, 1800)}>\r\n      <WebGLRendererConfig />\r\n      <ambientLight color={globeConfig.ambientLight} intensity={0.6} />\r\n      <directionalLight\r\n        color={globeConfig.directionalLeftLight}\r\n        position={new Vector3(-400, 100, 400)}\r\n      />\r\n      <directionalLight\r\n        color={globeConfig.directionalTopLight}\r\n        position={new Vector3(-200, 500, 200)}\r\n      />\r\n      <pointLight\r\n        color={globeConfig.pointLight}\r\n        position={new Vector3(-200, 500, 200)}\r\n        intensity={0.8}\r\n      />\r\n      <Globe {...props} />\r\n      <OrbitControls\r\n        enablePan={false}\r\n        enableZoom={false}\r\n        minDistance={cameraZ}\r\n        maxDistance={cameraZ}\r\n        autoRotateSpeed={1}\r\n        autoRotate={true}\r\n        minPolarAngle={Math.PI / 3.5}\r\n        maxPolarAngle={Math.PI - Math.PI / 3}\r\n      />\r\n    </Canvas>\r\n  );\r\n}\r\n\r\nexport function hexToRgb(hex: string) {\r\n  var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\r\n  hex = hex.replace(shorthandRegex, function (m, r, g, b) {\r\n    return r + r + g + g + b + b;\r\n  });\r\n\r\n  var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n  return result\r\n    ? {\r\n        r: parseInt(result[1], 16),\r\n        g: parseInt(result[2], 16),\r\n        b: parseInt(result[3], 16),\r\n      }\r\n    : null;\r\n}\r\n\r\nexport function genRandomNumbers(min: number, max: number, count: number) {\r\n  const arr = [];\r\n  while (arr.length < count) {\r\n    const r = Math.floor(Math.random() * (max - min)) + min;\r\n    if (arr.indexOf(r) === -1) arr.push(r);\r\n  }\r\n\r\n  return arr;\r\n}\r\n",
      "path": "/components/ui/github-globe.tsx",
      "target": "/components/mvpblocks/github-globe.tsx"
    }
  ]
}